# sql优化思路

1. explain 分析下 sql 语句
2. Extra 列不是 Using index ,考虑加索引优化
3. create index idx_age on user(age); 给 age 增加索引
4. 如果就查询 id, age ,这样有了 age 的辅助索引，并且 辅助索引的叶子存储的就是 age + 聚集索引（一般加在主键上，比如这里的 id）,这样达成了覆盖索引，不会回表



InnoDB 存储引擎对读操作支持两种一致性锁定读方式，或者说对读操作支持两种加锁方式：

SELECT ... FOR UPDATE，对于读取的行记录加一个 X 排它锁，其他事务不能对锁定的行加任何锁
SELECT ... LOCK IN SHARE MODE，对于读取的行记录添加一个 S 共享锁。其它事务可以向被锁定的行加 S 锁，但是不允许添加 X 锁，否则会被阻塞住
So，如何用大白话解释一致性锁定读？上面这两条特殊的 select 语句就是一致性锁定读！一致性锁定读就是给行记录加 X 锁或 S 锁！



# mvcc （Multi Version Concurrency Control，多版本并发控制）

总结下，通过 undo log 版本链和 ReadView 机制：

可以保证一个事务不会读到并发执行的另一个事务的更新
可以保证一个事务只可以读到该事务自己修改的数据或该事务开始之前的数据
另外，前文说过，一致性非锁定读（或者直接说 MVCC 吧，毕竟一致性非锁定读也是靠 MVCC 实现的）只在事务隔离级别 READ COMMITTED 和 REPEATABLE READ（默认）下才会开启，那对于这两个隔离级别，其实最根本的不同之处，就在于它们生成 ReadView 的时机不同，这个我们留在下文解释~


不过好在锁只会带来四种问题（丢失更新、脏读、不可重复读、幻读），如果可以防止这四种情况的发生，那将不会产生并发异常。为此，ISO 和 ANIS SQL 标准制定了四种事务隔离级别标准，用来对应地解决锁带来的几种问题。

四种事务隔离级别标准
SQL 标准定义了四种越来越严格的事务隔离级别，用来解决我们上述所说的四种事务的并发一致性问题。

1）READ UNCOMMITTED 读取未提交：事务中的修改，即使没有提交，对其它事务也是可见的。

上面提到过，数据库本身其实已经具备阻止丢失更新的能力，也就是说，即使是最低的隔离级别也可以阻止丢失更新问题。所以：

这个隔离级别可以阻止 丢失更新
2）READ COMMITTED 读取已提交：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

这个隔离级别可以阻止 丢失更新 + 脏读
3）REPEATABLE READ 可重复读（InnoDB 存储引擎默认的隔离级别）：保证在同一个事务中多次读取同一数据的结果是一样的

这个隔离级别可以阻止 丢失更新 + 脏读 + 不可重复读
4）SERIALIZABL 可串行化：强制事务串行执行（需要使用锁机制来实现），这样多个事务互不干扰，不会出现并发一致性问题。

这个隔离级别可以阻止 丢失更新 + 脏读 + 不可重复读 + 幻读


可以看到四种隔离级别能阻止的并发一致性问题越来越多，但并不代表越高的隔离级别就越好，因为事务隔离级别越高，数据库付出的性能代价也就相应地越大。


另外，多提一嘴，InnoDB 存储引擎在 REPEATABLE READ 事务隔离级别下，使用 Next-Key Lock 锁的算法避免了幻读的产生。也就是说，InnoDB 存储引擎在其默认的 REPEATABLE READ 事务隔离级别下就已经能完全保证事务的隔离性要求了，即达到了 SQL 标准的 SERIALIZABLE 隔离级别。




